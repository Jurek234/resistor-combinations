import numpy as np
import itertools, time
import os
from subset_sum import get_subset
from utils import render_grid

## GENERATE CIRCUIT GRIDS

start_t = time.time()

def generate_grids(total_resistors: int):
    """ circuits are generated line by line. 
    0 "total_resistors", tr = input
    1 "max_x_complexity" max_x = tr * 2
        > determines maximum width of grid. Leaves possibility for horizontal space after every resistor.
    2 "max_y_complexity" max_y = tr
        > determines maximum height of grid. Empty lines are deleted after generation."""
    tr = total_resistors
    max_x = tr; y = tr

    # # # generate distribution poosibilities for resistors
    """generate a list with len max_y and sum of elements tr that contains amount of resistors on each row."""
    # generate available numbers
    """get possiblities of combinations with generated partials (e.g. [1, 1, 1, 2, 3] for tr = 3)"""
    partials = []
    for i in range(1, tr+1):
        for _ in range(tr//i): partials.append(i)
    # generate possible distributions
    distributions = get_subset(partials, tr); # get possible distributions with given numbers
    distributions.sort(); # f: remove duplicates from distributions
    distributions = list(distributions for distributions,_ in itertools.groupby(distributions))
    # fill up to len() = y
    for d in distributions:
        if len(d) < y:
            for _ in range(y - len(d)): d.append(0)

    # # # generate grids from distributions
    """
    grids are generated by permutation of distributions lines with max_x as width,
    e.g [0, 0, 1], [1, 0, 0], [0, 1, 0] for max_x = 3
    
    """
    all_grids = []
    for dist in distributions:
        rows = []
        for i, line_length in enumerate(dist):
            rows.append([])
            indices = list(itertools.permutations(range(max_x), line_length))
            for indexx in indices:
                base = [0 for _ in range(max_x)]
                for pos in indexx: base[pos] = 1
                # check if row is 0
                """0 rows do not have any impact on grids, so they are removed to safe computations"""
                for p in base: 
                    if p == 1: break
                else: continue
                rows[i].append(base)
        grids = list(itertools.product(*rows))
        for g in grids: all_grids.append(g)
    return all_grids

def get_grid_value(grid: list, v: int = 2):
    """
    every grid has a value resistors combine to. It has to be computed to find out,
    how many unique values there are with given ammount of resitors.
    To procress grids are transposed and converted: 1 = true, 0 = false.
    If position is processed, it gets marked as false.
    """ 
    # convert grid
    grid = np.array(grid).T.tolist()
    # initialize variables
    height = len(grid); width = len(grid[0]); value = 0

    for r in grid:
        for i, p in enumerate(r):
            if p == 0: r[i] = None
            if p == 1: r[i] = True

    for row_index, row in enumerate(grid):
        r_count = 0
        for p in row:
            if not p == None: r_count += 1
        if r_count == 0: continue # empty row
        elif r_count == 1: value += v # row with one resistor
        else: # row with more than one resistor (parallel)
            for i, p in enumerate(row): # go trough row positions
                if not p: continue # pos = false
                parallels = 0 # number of resistors in that row
                for ri, row in enumerate(grid):
                    if not ri >= row_index: continue
                    if row[i]: 
                        parallels += 1 # add one to parallels if there is resistor on same pos
                        row[i] = False # indicate resitor was used
                    else: break
                row_val = 1/(parallels*v)
                value += row_val
    return value
                    

class Grid:
    def __init__(self, l) -> None:
        self.l = l
        self.v = get_grid_value(self.l)

RESISTORS = 4

grids = generate_grids(RESISTORS)
for _ in range(len(grids)):
    g = Grid(grids.pop())
    grids = [g] + grids

# # # filter unique grids
know_values = []
unique_grids = []
for g in grids:
    if not g.v in know_values:
        know_values.append(g.v)
        unique_grids.append(g)

end_t = time.time()

# # # render grids
os.system("clear")

for g in grids:
    render_grid(g)

print()
print("==================")
print()

for g in unique_grids:
    render_grid(g)

print(f"amount of resistors: {RESISTORS}")
print(f"(total grids: {len(grids)})")
print(f"total unique grids: {len(unique_grids)}")

print(f"execution time: {round(end_t - start_t, 3)}s")
input("...")

"""
ANSATZ FUNKTIONIERT NUR ANSATZWEISE
die Generation der Grids scheint nicht richtig
zu funktionieren, ich glaube, dass nicht alle
MÃ¶glichkeiten abgedeckt werden. Output = Falsch.
"""
    
